abstract contract TokenVesting {
    address public beneficiary = <%= vestingBeneficiary %>;
    uint256 public cliff;
    uint256 public start;
    uint256 public vestingDuration;
    bool public revocable = <%= revocable %>; // true o false

    uint256 public released;
    bool public revoked;
    address public owner;

    event TokensReleased(uint256 amount);
    event VestingRevoked();

    function _transferVestedTokens(address beneficiary, uint256 amount) internal virtual;

    constructor(uint256 _start) {
        owner = msg.sender;
        beneficiary = <%= vestingBeneficiary %>;
        start = _start;
        cliff = _start + <%= cliffDuration %>;
        vestingDuration = <%= vestingDuration %>;
    }

    function release(uint256 totalBalance) public {
        require(block.timestamp >= cliff, "Tokens are still in cliff period");
        uint256 unreleased = releasableAmount(totalBalance);
        require(unreleased > 0, "No tokens are due for release");
        released += unreleased;
        _transferVestedTokens(beneficiary, unreleased);
        emit TokensReleased(unreleased);
    }

    function releasableAmount(uint256 totalBalance) public view returns (uint256) {
        return vestedAmount(totalBalance) - released;
    }

    function vestedAmount(uint256 totalBalance) public view returns (uint256) {
        if (block.timestamp < cliff) {
            return 0;
        } else if (block.timestamp >= start + vestingDuration || revoked) {
            return totalBalance;
        } else {
            return (totalBalance * (block.timestamp - start)) / vestingDuration;
        }
    }

    function revoke() public {
        require(revocable, "Vesting is not revocable");
        require(msg.sender == owner, "Only owner can revoke");
        require(!revoked, "Vesting already revoked");
        revoked = true;
        emit VestingRevoked();
    }
}
